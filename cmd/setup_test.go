package cmd_test

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"os"
	"reflect"
	"testing"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/raft-tech/syncd/internal/helpers"
)

func TestCLI(t *testing.T) {
	RegisterFailHandler(Fail)
	cfg, rep := GinkgoConfiguration()
	rep.VeryVerbose = true
	if d, ok := t.Deadline(); ok {
		cfg.Timeout = d.Sub(time.Now())
	}
	RunSpecs(t, "CLI", cfg, rep)
}

var clientTLS *tls.Config
var serverTLS *tls.Config

var configFile = []byte(`
client:
  name: alpha
  auth:
    preSharedKey:
      value: cookiecookiecookiecookie
    tls:
      crt: build/client.crt
      key: build/client.key
      ca:
        - build/server.crt
  metrics:
    listen: ":8081"
  peers:
    bravo:
      address: localhost:8080
      authority: syncd
      pull:
        - artists
        - songs
        #- performers
      push:
        artists:
          filters:
            - key: name
              operator: In
              value:
                - John Mayer
                - Steve Jordan
                - Pino Palladino
#        performers:
#          filters:
#            - key: label
#              operator: Equals
#              value: Sony Music Entertainment
        songs:
          filters:
            - key: publisher
              operator: In
              value:
                - Aware
                - Bluebird
                - Sony Music Entertainment

server:
  listen: ":8080"
  metrics:
    listen: ":8081"
  tls:
    crt: build/server.crt
    key: build/server.key
    ca:
      - build/client.crt
  auth:
    preSharedKey:
      value: cookiecookiecookiecookie
  models:
    artists:
      filters:
        - key: name
          operator: In
          value:
            - John Lennon
            - Paul McCartney
            - Ringo Starr
            - George Harrison
    performers:
      filters:
        - key: label
          operator: Equal
          value: VeeJay
    songs:
      filters:
        - key: publisher
          operator: Equal
          value: VeeJay
graph:
  source:
    postgres:
      syncTable:
        name: syncd.sync
      sequenceTable:
        name: syncd.sync_seq
      connection:
        value: postgres://testing
  models:
    artists:
      table: syncd.artists
      key: id
      version: version
    songs:
      table: syncd.songs
      key: id
      version: version
    performers:
      table: syncd.performers
      key: id
      version: version
      children:
        artists:
          table: syncd.performer_artists
          key: performer
        performances:
          table: syncd.performances
          key: performer
          sequence: sequence
`)

var readme = []byte(`The files in this directory are generated by tests defined in cmd/setup_test.go.

The easiest way to clean them up is to run: make clean
`)

var _ = BeforeSuite(func() {

	GinkgoT().Log("creating build files")

	Expect(os.MkdirAll("build", 0755)).NotTo(HaveOccurred())

	Expect(os.WriteFile("build/README", readme, 0644)).NotTo(HaveOccurred())

	// Config file
	Expect(os.WriteFile("build/config.yaml", configFile, 0644)).NotTo(HaveOccurred())

	clientCAs := x509.NewCertPool()
	serverCAs := x509.NewCertPool()

	// Server Cert
	if crt, err := helpers.SelfSignedCertificate("syncd", "syncd"); err == nil {

		// TLS Config for Servers
		serverTLS = &tls.Config{
			Certificates: []tls.Certificate{*crt},
			ClientAuth:   tls.RequireAndVerifyClientCert,
			ClientCAs:    clientCAs,
		}
		serverCAs.AddCert(crt.Leaf) // used by clients to auth servers

		// Write PEMs to disk for CLI commands
		buf := new(bytes.Buffer)
		for _, b := range crt.Certificate {
			block := pem.Block{
				Type:  "CERTIFICATE",
				Bytes: b,
			}
			Expect(pem.Encode(buf, &block)).To(Succeed())
		}
		Expect(os.WriteFile("build/server.crt", buf.Bytes(), 0644)).NotTo(HaveOccurred())
		buf.Reset()
		var b []byte
		switch crt.PrivateKey.(type) {
		case *ecdsa.PrivateKey:
			b, err = x509.MarshalECPrivateKey(crt.PrivateKey.(*ecdsa.PrivateKey))
			Expect(err).NotTo(HaveOccurred())
		default:
			Fail("unrecognized private key type: " + reflect.TypeOf(crt.PrivateKey).String())
			return
		}
		Expect(pem.Encode(buf, &pem.Block{
			Type:  "PRIVATE KEY",
			Bytes: b,
		})).To(Succeed())
		Expect(os.WriteFile("build/server.key", buf.Bytes(), 0640)).NotTo(HaveOccurred())
	} else {
		Expect(err).NotTo(HaveOccurred())
	}

	// Client Cert
	if crt, err := helpers.SelfSignedCertificate("client"); err == nil {

		// TLS Config for Clients
		clientTLS = &tls.Config{
			Certificates: []tls.Certificate{*crt},
			RootCAs:      serverCAs,
		}
		clientCAs.AddCert(crt.Leaf) // Used by servers to auth clients

		// Write PEMs to disk for CLI commands
		buf := new(bytes.Buffer)
		for _, b := range crt.Certificate {
			block := pem.Block{
				Type:  "CERTIFICATE",
				Bytes: b,
			}
			Expect(pem.Encode(buf, &block)).To(Succeed())
		}
		Expect(os.WriteFile("build/client.crt", buf.Bytes(), 0644)).NotTo(HaveOccurred())
		buf.Reset()
		var b []byte
		switch crt.PrivateKey.(type) {
		case *ecdsa.PrivateKey:
			b, err = x509.MarshalECPrivateKey(crt.PrivateKey.(*ecdsa.PrivateKey))
			Expect(err).NotTo(HaveOccurred())
		default:
			Fail("unrecognized private key type: " + reflect.TypeOf(crt.PrivateKey).String())
			return
		}
		Expect(pem.Encode(buf, &pem.Block{
			Type:  "PRIVATE KEY",
			Bytes: b,
		})).To(Succeed())
		Expect(os.WriteFile("build/client.key", buf.Bytes(), 0640)).NotTo(HaveOccurred())
	} else {
		Expect(err).NotTo(HaveOccurred())
	}
})
